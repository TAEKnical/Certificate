# 1. 쿠버네티스란



## 1) 쿠버네티스

\- 컨테이너화된 애플리케이션을 배포하기 위한 오픈 소스 오케스트레이터

\- 구글의 오픈소스 공개와 활발한 기여자들

\- 자체적인 재해 복구 알고리즘

\- 무중단 업데이트와 로드 밸런서



\## 2) 쿠버네티스의 오케스트레이션

\- 헬스 체크(사용자 정의 상태 검사), 라이브니스 체크(교착 상태로 인한 재시작 필요성 검사), 레디니스 체크(로드 밸런싱 필요성 검사)



\## 3) 쿠버네티스 API

\- HTTP 및 JSON 기반의 RESTful API이며, API 서버가 제공됨

\- 쿠버네티스의 모든 컴포넌트는 API를 이용해 통신함



\# 2. 쿠버네티스 오브젝트

\* 쿠버네테스에서 컨트롤러는 각 오브젝트를 제어하는 역할

\## 1) 기본 오브젝트

파드, 레플리카셋, 서비스, 라이브니스 프로브, 잡, 크론잡, 데몬셋, 네임스페이스, 레이블, 레이블 셀렉터, 어노테이션



\- 파드 : 쿠버네티스 클러스터에서 스케줄링, 스케일링, 복제되는 가장 작은 단위. 하나 이상의 실행 중인 컨테이너로 구성. 각 컨테이너는 파드 단위로 부여되는 리소스와 네임스페이스를 공유함. 



\- 레플리카셋 : 애플리케이션을 여러 컨테이너에 복제해 둠으로써 개별 컨테이너에 문제가 발생해도 서비스가 중단될 가능성이 크게 줄어든다. 쿠버네티스에서 이러한 종류의 Stateless 복제를 레플리카셋 오브젝트로 처리한다. 즉, 정의된 파드의 복제본(레플리카)을 만들어주는 오브젝트이다. 기존의 레플리케이션 컨트롤러는 더이상 사용이 권장되지 않는다.



\- 라이브니스 프로브 : 파드에서 동작중인 각 컨테이너가 정상적으로 동작하고 있는지 주기적으로 모니터링하는 오브젝트이다. 만약 컨테이너에서 오류가 발생하면 라이브니스 프로브에 의해 재시작 하게 된다. HTTP GET, TCP 포트연결, Exec 바이너리와 같이 세 가지 방식이 있다.



\- 잡 : 쿠버네티스에서 잡은 시작과 끝이 있는, 일회성의 작업 집합을 의미한다. 잡 역시 컨테이너 이미지를 실행하여 작업을 실행하는 파드를 만들고 동작한다. 목표 작업이 완료되면 파드가 종료된다.



\- 크론잡 : 리눅스 크론탭이랑 같은 개념. 특정 시간에 특정 작업을 하는 잡 오브젝트.



\- 데몬셋 : 노드마다 기본적으로 존재해야 하는 파드 템플릿을 세팅할 수 있는 오브젝트이다. 새로운 노드가 추가되더라도 해당 노드에서 데몬셋 파드가 실행중인지 체크하고 추가한다.



네임스페이스, 레이블, 어노테이션



\- 네임스페이스 : 쿠버네티스 오브젝트를 위한 폴더와 같다. 역할 기반 접근 제어(RBAC, Role-Based Access Control) 규칙의 범위로 쓰일 수도 있다. 네임스페이스를 삭제하면 포함된 오브젝트도 모두 삭제되므로 관리시 주의가 필요하다. 모든 쿠버네티스 클러스터에는 default라는 이름의 기본 네임스페이스가 존재한다.



\- 레이블과 레이블 셀렉터 : 쿠버네티스의 모든 오브젝트는 레이블 집합으로 묶일 수 있다. 레이블은 각 오브젝트를 식별하기 위한 key-value 쌍이다. 레이블을 조회하기 위한 요청을 레이블 쿼리 또는 레이블 셀렉터라고 한다. 



\- 어노테이션 : 오브젝트에 메타데이터를 추가하기 위한 주석 오브젝트. 오브젝트라고 하기도 뭐하다.



\## 2) 스토리지 오브젝트

퍼시스턴트 볼륨, 컨피그맵, 시크릿



\- 퍼시스턴트 볼륨 : 볼륨은 파드 오브젝트의 잉ㄹ부로서, 파드를 정의할 때 볼륨을 함께 정의할 수 있다. 다양한 유형이 제공되며 그 중에 퍼시스턴트 볼륨이 있다. 퍼시스턴트 볼륨은 파드에 직접 볼륨을 결합하는 대신 퍼시스턴트 볼륨 오브젝트가 별도로 생성되며 퍼시스턴트 볼륨 요청(PVC)이 퍼시스턴트 볼륨(PV) 오브젝트를 특정 파드에 할당한다. 이 과정은 다소 복잡하나 볼륨과 파드를 추상화 함으로써 이식성과 자동 볼륨 생성을 가능하게 한다.



\- 컨피그맵 : 설정, 변수, 설정파일의 값을 key-value 형태로 저장할 수 있는 저장소 오브젝트이다. 파드를 생성할 때 참조시켜서 변수를 불러오거나 추가할 볼륨에 초기값을 세팅하기 위한 용도로 쓰인다.



\- 시크릿 : 컨피그 맵과 같은 key-value 저장소 오브젝트이나, 인코딩이 필요한 민감한 데이터를 안전하게 관리하기 위한 용도로 쓰인다. 



\## 3) 네트워크 오브젝트

서비스, 인그레스, 레디니스 프로브, 헤드리스



\- 서비스 : 레플리카셋으로 복제하여 안정성을 확보했으면 다음 목표는 이들 복제본에 로드밸런싱을 하는 것이다. 쿠버네티스의 서비스 오브젝트는 TCP/UDP 기반의 로드 밸런싱(L4 로드밸런싱)을 구현한다. 부여된 고정 IP는 쿠버네티스 클러스터 내의 DNS 서버에 기록된다. 세션 어피니티를 함께 정의하여 매번 같은 파드로 연결시킬 수도 있다. 서비스는 기능에 따라 네 가지 종류가 존재한다.

[1] Cluster IP : 쿠버네티스 클러스터 내부에서만 접근 가능

[2] NodePort : 노드마다 외부 접근용 포트를 할당해서 해당 포트에 접근하면 파드로 리다이렉션.

[3] LoadBalancer : 클러스터 외부에 로드 밸런서를 배치하고 로드 밸런서에 접근하면 파드로 리다이렉션.

[4] ExternalName : 외부에서 접근하기 위한 용도는 아니고 FQDN에 대한 CNAME 매핑을 제공. 파드가 CNAME과 FQDN으로 통신하기 위해서 쓰는 것.



\*서비스 오브젝트 자체가 L4이기 때문에 Nodeport와 Loadbalancer 유형도 모두 L4단에서 동작한다는 점에 유의



\- 인그레스 : 서비스 오브젝트는 간단한 TCP 수순의 로드밸런싱에는 좋지만 애플리케이션 수준의 로드 밸런싱(L7)과 라우팅은 제공하지 않는다. 이를 제공하기 위해 인그레스 오브젝트가 추가되었다. 



\- 레디니스 프로브 : 주기적으로 파드를 모니터링하여 애플리케이션의 동작이 준비되었는지 확인하는 오브젝트이다. 동작 준비가 된 파드를 체크해서 서비스의 엔드포인트에 파드의 주소를 등로갛고, 동작 준비가 되지 않았다면 등록하지 않는다. 레디니스 프로브가 설정되지 않으면 동작 준비를 확인하지 않고 바로 엔드포인트에 파드를 등록해버린다. 이 역시 HTTP GET, TCP 포트 연결, Exec 바이너리 세 가지 방식의 프로브를 유형이 있다.



\- 헤드리스 : 클라이언트 측 파드에서 서버 측 서비스를 통해 각각 개별 파드로 접근해야 하는 경우도 있다. 서비스의 IP가 아닌 파드 자체의 IP를 확인해야 한다는 의미인데, 이 경우 헤드리스 오브젝트를 사용한다. 예를 들어 마스터DB(읽기/쓰기)와 슬레이브DB(읽기 전용) 파드가 나누어져 있는 경우, 쓰기 작업과 읽기 작업에 따라 특정 파드로 접근해야 하는 상황이 발생한다.



\## 4) 고급 오브젝트

디플로이먼트, 스테이트풀셋



\- 디플로이먼트 : 레플리카셋은 동일한 컨테이너 이미지로 여러 복제본을 실행하지만, 애플리케이션은 정적이지 않으며 매번 디버깅과 버전업을 거친다. 이 때 새 코드를 서비스에 적용하는 '롤아웃'을 안전하게 할 수 있도록 하는 오브젝트가 디플로이먼트 오브젝트이다. v1 레플리카 3개가 있으면 디플로이먼트는 v2를 새로 만들고 v1을 한 개 줄이고 v1을 한 개 늘리면서 안정성을 체크하는 방식으로 롤아웃을 진행한다. 실무에서는 디플로이먼트 오브젝트를 많이 쓰고 레플리카셋 오브젝트에 직접 작업하지 않는다.



\- 스테이트풀셋 : 레플리카셋으로 생성한 레플리카 간에는 구분되는 고유한 ID가 없다. statefull한 workload를 위해서는 애플리케이션 레플리카간의 구분이 필요하다. 레플리카셋으로 생성한 애플리케이션 단에서 수작업을 거칠 수는 있지만 이는 비효율적이다. 이 문제를 해결하기 위해서 스테이트풀셋 오브젝트가 레플리카셋의 보완책으로 추가되었다. 원래 레플리카셋에서는 단순 해시값만 가졌는데 스테이트풀셋에서 각 파드는 index값을 부여받고 초기 레플리카는 0번 인덱스가 된다.